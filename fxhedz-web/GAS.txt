// ======================================================
// CONFIG
// ======================================================
const TOKEN = PropertiesService.getScriptProperties().getProperty("BOT_TOKEN");
const WEBHOOK_SECRET = PropertiesService.getScriptProperties().getProperty("WEBHOOK_SECRET");
const SPREADSHEET_ID = "1jMlONsIzwXyf_j9y96HkeIwRh0OynfTUak3MvHrJLyo";
const SHEET_NAME = "USERS_AUTH";
const ADMIN_CHAT_ID = "7115081072";

const PAIRS = [
    "XAUUSD",
    "BTCUSD",
    "ETHUSD",
    "EURUSD",
    "GBPUSD",
    "USDJPY",
    "AUDUSD",
    "USDCHF",
    "USOIL"
];

function getPairPerformanceCache() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("PAIR_PERFORMANCE")
    return raw ? JSON.parse(raw) : {}
}

function setPairPerformanceCache(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("PAIR_PERFORMANCE", JSON.stringify(data))
}

function getLiveSignals() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("LIVE_SIGNALS");

    let data = raw ? JSON.parse(raw) : {};

    // üî• AUTO-CLEAN INVALID KEYS
    Object.keys(data).forEach(k => {
        const key = (k || "").toUpperCase().trim();
        if (PAIRS.indexOf(key) === -1) {
            delete data[k];
        }
    });

    return data;
}

function setLiveSignals(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("LIVE_SIGNALS", JSON.stringify(data));
}

function getOrderHistory() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("ORDER_HISTORY")
    return raw ? JSON.parse(raw) : {}
}

function setOrderHistory(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("ORDER_HISTORY", JSON.stringify(data))
}

function appendHistoryRow(instrument, direction, entry, exit, pnl, time) {

    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID)
        .getSheetByName("ORDER_HISTORY")

    sheet.appendRow([
        time,
        instrument,
        direction,
        entry,
        exit,
        pnl
    ])
}

function getMarketNotes() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("MARKET_NOTES")
    return raw ? JSON.parse(raw) : {}
}

function setMarketNotes(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("MARKET_NOTES", JSON.stringify(data))
}

function handleAuthUser(email, deviceId, fingerprint, platform, telegramChatId) {

    if (!email || !fingerprint) {
        return {
            blocked: true
        };
    }

    email = String(email).toLowerCase().trim();
    platform = platform || "web";
    telegramChatId = telegramChatId || "";

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    let rowIndex = -1;
    let rowData = null;

    for (let i = 1; i < rows.length; i++) {
        if (String(rows[i][0] || "").toLowerCase() === email) {
            rowIndex = i;
            rowData = rows[i];
            break;
        }
    }

    // ============================
    // NEW USER
    // ============================
    if (rowIndex === -1) {

        const expiry = new Date(now);
        expiry.setDate(expiry.getDate() + 14);

        const devicePayload = {
            devices: [{
                device_id: deviceId,
                fingerprint: fingerprint,
                platform: platform,
                last_active: now.toISOString()
            }]
        };

        sheet.appendRow([
            email,
            now,
            expiry,
            "live",
            0,
            "",
            telegramChatId,
            "",
            JSON.stringify(devicePayload),
            true,
            "",
            ""
        ]);

        return {
            active: true,
            plan: "live",
            expiry
        };
    }

    // ============================
    // EXISTING USER
    // ============================

    const expiry = rowData[2] ? new Date(rowData[2]) : new Date(0);
    const plan = String(rowData[3] || "").toLowerCase();
    if (telegramChatId) {
        const existingChatId = rowData[6] || "";
        if (!existingChatId) {
            sheet.getRange(rowIndex + 1, 7).setValue(telegramChatId);
        } else if (existingChatId !== telegramChatId) {
            return {
                blocked: true,
                reason: "telegram_mismatch"
            };
        }
    }
    const active = expiry > now;

    if (!active) {
        return {
            active: false,
            plan,
            expiry
        };
    }

    let devicePayload;
    try {
        devicePayload = JSON.parse(rowData[8] || "{}");
    } catch {
        devicePayload = {
            devices: []
        };
    }

    if (!devicePayload.devices) devicePayload.devices = [];

    const devices = devicePayload.devices;

    // 1Ô∏è‚É£ Fingerprint already exists ‚Üí allow
    const existing = devices.find(d => d.fingerprint === fingerprint);
    if (existing) {
        existing.last_active = now.toISOString();
        sheet.getRange(rowIndex + 1, 9)
            .setValue(JSON.stringify(devicePayload));
        return {
            active,
            plan,
            expiry
        };
    }

    // 2Ô∏è‚É£ Under device limit ‚Üí add
    if (devices.length < 2) {

        devices.push({
            device_id: deviceId,
            fingerprint: fingerprint,
            platform: platform,
            last_active: now.toISOString()
        });

        sheet.getRange(rowIndex + 1, 9)
            .setValue(JSON.stringify(devicePayload));

        return {
            active,
            plan,
            expiry
        };
    }

    // 3Ô∏è‚É£ Exceeded device limit
    return {
        blocked: true,
        reason: "device_limit_exceeded"
    };
}

function handleDeviceAccess(sheet, userRows, email, deviceId, fingerprint, platform, telegramChatId) {

    const now = new Date();

    platform = (platform || "web").toLowerCase().trim();

    const hasPaid = userRows.some(u =>
        String(u.row[3] || "").toLowerCase() === "live+"
    );

    // =========================================
    // GROUP ROWS BY PLATFORM
    // =========================================
    const platformRows = userRows.filter(u =>
        String(u.row[10] || "").toLowerCase() === platform
    );

    const usedPlatforms = [
        ...new Set(userRows.map(u => String(u.row[10] || "").toLowerCase()))
    ].filter(Boolean);

    // =========================================
    // 1Ô∏è‚É£ EXISTING FINGERPRINT (Exact Match)
    // =========================================
    const existing = userRows.find(u =>
        String(u.row[8] || "") === fingerprint
    );

    if (existing) {

        const expiry = existing.row[2] ? new Date(existing.row[2]) : new Date(0);
        const plan = String(existing.row[3] || "").toLowerCase();

        const active = expiry > now;

        // Telegram binding logic (unchanged but cleaner)
        if (telegramChatId) {

            const mismatch = userRows.some(u =>
                String(u.row[6] || "") &&
                String(u.row[6]) !== telegramChatId
            );

            if (mismatch) {
                return {
                    blocked: true,
                    reason: "telegram_mismatch"
                };
            }

            userRows.forEach(u => {
                sheet.getRange(u.index + 1, 7).setValue(telegramChatId);
            });
        }

        return {
            active,
            plan,
            expiry
        };
    }

    // =========================================
    // 2Ô∏è‚É£ SAME PLATFORM ‚Üí REPLACE FINGERPRINT
    // =========================================
    if (platformRows.length > 0) {

        const rowToReplace = platformRows[0];

        sheet.getRange(rowToReplace.index + 1, 9).setValue(fingerprint);
        sheet.getRange(rowToReplace.index + 1, 8).setValue(deviceId);

        return {
            active: true,
            plan: rowToReplace.row[3],
            expiry: rowToReplace.row[2]
        };
    }

    // =========================================
    // 3Ô∏è‚É£ NEW PLATFORM ENTRY
    // =========================================

    const platformLimit = hasPaid ? 2 : 3;
    // FREE = 3 (web + telegram + android)
    // PAID = 2 (max 2 platforms active)

    if (usedPlatforms.length >= platformLimit) {
        return {
            blocked: true,
            reason: "platform_limit_exceeded"
        };
    }

    const baseRow = userRows[0].row;

    sheet.appendRow([
        email,
        baseRow[1],
        baseRow[2],
        baseRow[3],
        baseRow[4],
        baseRow[5],
        telegramChatId || baseRow[6],
        deviceId,
        fingerprint,
        baseRow[9],
        platform,
        baseRow[11]
    ]);

    return {
        active: true,
        plan: baseRow[3],
        expiry: baseRow[2]
    };
}

function checkAuthUser(email) {

    if (!email) return {
        active: false
    };

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    email = email.toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][0] || "").toLowerCase() !== email) continue;

        const expiry = rows[i][2] ? new Date(rows[i][2]) : new Date(0);
        const plan = String(rows[i][3] || "").toLowerCase();

        if (expiry > now) {
    return { active: true, plan, expiry };
}
    }

    return {
        active: false
    };
}

// ======================================================
// SINGLE WEBHOOK ENTRY - WRITE pipeline (MT5 ‚Üí GAS)
// ======================================================
function doPost(e) {
    const ack = ok();

    try {
        if (!e || !e.postData || !e.postData.contents) return ack;
        // ===============================
        // GOOGLE AUTH SYNC
        // ===============================
        const contentType = e.postData.type || "";

        if (contentType.indexOf("application/json") !== -1) {

            const data = JSON.parse(e.postData.contents);

            // ===============================
            // RESET DEVICES
            // ===============================
            if (data.reset_devices && data.email) {

                const result = resetUserDevices(data.email);

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }

            // ===============================
            // ANDROID BILLING
            // ===============================
            if (data.purchase_token && data.email && data.platform === "android") {

                const result = activateAndroidPurchase(
                    data.email,
                    data.purchase_token,
                    data.months || 1
                );

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }

            // ===============================
            // APP LOGIN
            // ===============================
            if (data.email) {

                const result = handleAuthUser(
                    data.email,
                    data.device_id || "",
                    data.fingerprint || "",
                    data.platform || "web",
                    data.telegram_chat_id || ""
                );

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }
        }

        const type = e.postData.type || "";

        // ==================================================
        // TELEGRAM (JSON)
        // ==================================================
        if (type.indexOf("application/json") !== -1) {
            const data = JSON.parse(e.postData.contents);
            handleTelegram(data);
            return ack;
        }

        // ==================================================
        // MT5 SCREENSHOT (RAW BINARY) ‚Äî MUST COME FIRST
        // ==================================================
        if (
            type.indexOf("application/json") === -1 &&
            type.indexOf("application/x-www-form-urlencoded") === -1
        ) {
            const secret = (e.parameter && e.parameter.secret || "").trim();
            if (secret !== WEBHOOK_SECRET) return ack;

            // üîë THE FIX ‚Äî binary-safe read
            const bytes = e.postData.getBytes();
            if (!bytes || bytes.length < 2000) return ack;

            const blob = Utilities.newBlob(
                bytes,
                "image/jpeg",
                "chart.jpg"
            );

            const tx = (e.parameter && e.parameter.tx) || "";
            dispatchImageToUsers(blob, tx);

            return ack; // ‚õî DO NOT FALL THROUGH
        }

        // ==================================================
        // MT5 TEXT ALERT (FORM URLENCODED)
        // ==================================================
        const params = {};
        e.postData.contents.split("&").forEach(p => {
            const idx = p.indexOf("=");
            if (idx === -1) return;
            const k = decodeURIComponent(p.substring(0, idx));
            const v = decodeURIComponent(p.substring(idx + 1));
            params[k] = v;
        });

        if ((params.secret || "").trim() !== WEBHOOK_SECRET) return ack;

        // ============================
        // MARKET NOTES UPDATE (ADD HERE)
        // ============================
        if (params.notes) {
            updateMarketNotes(params.notes);
            return ack;
        }

        // normal signal flow
        if (!params.message) return ack;

        handleSignal(params.message.trim(), params.tx);

        return ack;

    } catch (err) {
        send(ADMIN_CHAT_ID, "‚ùå GAS ERROR\n<code>" + err + "</code>");
        return ack;
    }
}

function requireSignalAccess(email) {

    const auth = checkAuthUser(email);

    if (!auth || !auth.active) {
        return {
            blocked: true,
            plan: auth ? auth.plan : "none",
            expiry: auth ? auth.expiry : null
        };
    }

    return {
        blocked: false,
        plan: auth.plan,
        expiry: auth.expiry
    };
}

// ======================================================
// READ pipeline  (WebApp ‚Üí GAS)
// ======================================================

function doGet(e) {

    const secret = (e.parameter.secret || "").trim();

    if (secret !== WEBHOOK_SECRET) {
        return ContentService.createTextOutput("unauthorized");
    }

    const deviceId = (e.parameter.device_id || "").trim();
    const fingerprint = (e.parameter.fingerprint || "").trim();
    const pair = (e.parameter.pair || "").toUpperCase();

    if (!fingerprint) {
        return jsonBlocked();
    }

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        let devicePayload;
        try {
            devicePayload = JSON.parse(rows[i][8] || "{}");
        } catch {
            continue;
        }

        const devices = devicePayload.devices || [];
        const match = devices.find(d => d.fingerprint === fingerprint);

        if (!match) continue;

        const expiry = rows[i][2] ? new Date(rows[i][2]) : new Date(0);
        const plan = String(rows[i][3] || "").toLowerCase();

        const active = expiry > now;

        if (!active) {
            return jsonBlocked(plan, expiry);
        }

        return buildSignalResponse({
            plan,
            expiry
        }, pair);
    }

    return jsonBlocked();
}

function resetUserDevices(email) {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();

    email = email.toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][0] || "").toLowerCase() === email) {

            sheet.getRange(i + 1, 9)
                .setValue(JSON.stringify({
                    devices: []
                }));

            return {
                success: true
            };
        }
    }

    return {
        success: false
    };
}

function jsonBlocked(plan, expiry) {
  return ContentService
    .createTextOutput(JSON.stringify({
      blocked: false,   // üî• CRITICAL FIX
      active: false,
      plan: plan || null,
      expiry: expiry || null
    }))
    .setMimeType(ContentService.MimeType.JSON);
}

function buildSignalResponse(access, pair) {

    const signals = getLiveSignals();

    if (pair) {

        const data = getPairDataFromSheet(pair);
        const notes = getMarketNotes();
        const orders = signals[pair]?.orders || [];

        return ContentService
            .createTextOutput(JSON.stringify({
                blocked: false,
                active: true,
                plan: access.plan,
                expiry: access.expiry,
                signals,
                history: data.history,
                performance: data.performance,
                notes: notes[pair] || "",
                orders
            }))
            .setMimeType(ContentService.MimeType.JSON);
    }

    return ContentService
        .createTextOutput(JSON.stringify({
            blocked: false,
            active: true,
            plan: access.plan,
            expiry: access.expiry,
            signals
        }))
        .setMimeType(ContentService.MimeType.JSON);
}

// ======================================================
// TELEGRAM HANDLER
// ======================================================
function handleTelegram(data) {

    const cache = CacheService.getScriptCache();

    const updKey = data.update_id ? String(data.update_id) : Utilities.getUuid();
    if (cache.get(updKey)) return;
    cache.put(updKey, "1", 300);

    if (data.callback_query) {
        handleCallback(data.callback_query);
        return;
    }

    if (!data.message || !data.message.text) return;

    const chatId = String(data.message.chat.id);
    const text = data.message.text.trim();
    const from = data.message.from || {};

    // CORE ENTRY
    if (text === "/start") return onStart(chatId, from);

    // OPTIONAL TOOL
    if (text === "/myid") return onMyId(chatId);

    // UI ROUTING (emoji safe)
    if (text) {
        if (text.includes("PAIR")) return onInstruments(chatId);
        if (text.includes("LIVE")) return onSubscription(chatId);
        if (text.includes("READ")) return onBooks(chatId);
        if (text.includes("HELP")) return onSupport(chatId);
    }

    // ADMIN
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/activate")) return onActivate(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/deactivate")) return onDeactivate(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/sendall")) return onBroadcast(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/reply")) return onAdminReply(text);
}

function setBotCommands() {
    const url = "https://api.telegram.org/bot" + TOKEN + "/setMyCommands";

    const payload = {
        commands: [{
                command: "start",
                description: "Open main menu"
            },
            {
                command: "pair",
                description: "Select instruments"
            },
            {
                command: "live",
                description: "View live+ plans"
            },
            {
                command: "read",
                description: "Forex Trilogy Books"
            },
            {
                command: "myid",
                description: "Show your Chat ID"
            },
            {
                command: "help",
                description: "Support & assistance"
            },
        ]
    };

    UrlFetchApp.fetch(url, {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify(payload)
    });
}

function onInstruments(chatId) {

    let selected = getTempInstruments(chatId);

    // if temp not exists load from sheet
    if (!selected) {
        selected = getUserInstruments(chatId);
        setTempInstruments(chatId, selected);
    }

    sendRich(
        chatId,
        "üîî <b>Select Trading Instruments</b>\n\nToggle pairs then press Confirm.",
        buildInstrumentKeyboard(selected)
    );
}

function buildInstrumentKeyboard(selected) {

    const rows = [];
    let currentRow = [];

    // build 2 buttons per row automatically
    PAIRS.forEach((pair, index) => {

        currentRow.push({
            text: toggleText(pair, selected),
            callback_data: "inst_tmp_" + pair
        });

        if (currentRow.length === 2) {
            rows.push(currentRow);
            currentRow = [];
        }
    });

    // push remaining button if odd count
    if (currentRow.length) rows.push(currentRow);

    // add confirm/cancel row
    rows.push([{
            text: "‚úÖ Confirm",
            callback_data: "inst_confirm"
        },
        {
            text: "‚ùå Cancel",
            callback_data: "inst_cancel"
        }
    ]);

    return {
        inline_keyboard: rows
    };
}

function toggleText(inst, selected) {
    return (selected.indexOf(inst) !== -1 ? "üü¢ " : "‚ö™ ") + inst;
}

function onSignals(chatId) {

    if (!isUserAllowed(chatId)) {
        sendExpired(chatId);
        return;
    }

    send(
        chatId,
        "üìä <b>Open Signals Panel</b>\n\n" +
        "Tap the <b>Menu</b> button below the chat to launch live signals."
    );
}

let _sheet = null;

function mustGetSheet() {
    if (!_sheet) {
        _sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAME);
    }
    return _sheet;
}

function onActivate(text) {

    const parts = text.trim().split(/\s+/);
    if (parts.length < 3) {
        send(ADMIN_CHAT_ID, "Usage: /activate <chatId> <months>");
        return;
    }

    const chatId = parts[1];
    const months = parseInt(parts[2], 10);
    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][6]) === chatId) {

            const currentExpiry = new Date(rows[i][2]);
            const plan = String(rows[i][3]).toLowerCase();

            const baseDate =
                (plan === "live+" && currentExpiry > now) ?
                currentExpiry :
                now;

            const newExpiry = new Date(baseDate);
            newExpiry.setMonth(newExpiry.getMonth() + months);

            sheet.getRange(i + 1, 3).setValue(newExpiry); // C expiry
            sheet.getRange(i + 1, 4).setValue("live+"); // D plan
            sheet.getRange(i + 1, 5).setValue(months); // E plan_months

            send(chatId,
                "‚úÖ <b>Subscription Activated</b>\n\n" +
                "Plan: " + months + " month(s)\n" +
                "Valid till: " + formatDate(newExpiry)
            );

            return;
        }
    }

    send(ADMIN_CHAT_ID, "Chat ID not found.");
}

function onDeactivate(text) {
    const parts = text.trim().split(/\s+/);
    if (parts.length < 2) return;

    const chatId = parts[1];
    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {
        if (String(rows[i][6]) === chatId) {

            // HARD RESET
            sheet.getRange(i + 1, 3).setValue(new Date());
            sheet.getRange(i + 1, 4).setValue("expired");
            sheet.getRange(i + 1, 5).setValue(0);

            send(chatId, "‚õî <b>Your subscription has been deactivated</b>");

            send(
                ADMIN_CHAT_ID,
                "‚õî Deactivated " + chatId +
                " | months=0 | instruments cleared"
            );
            return;
        }
    }

    send(ADMIN_CHAT_ID, "‚ùå Chat ID not found: " + chatId);
}

function activateAuthUser(email, months) {

    const sheet = SpreadsheetApp
        .openById(SPREADSHEET_ID)
        .getSheetByName("USERS_AUTH");

    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][0]).toLowerCase() !== email.toLowerCase()) continue;

        const currentExpiry = new Date(rows[i][2]);
        const currentPlan = String(rows[i][3]).toLowerCase();

        let baseDate =
            (currentPlan === "live+" && currentExpiry > now) ?
            currentExpiry :
            now;

        const newExpiry = new Date(baseDate);
        newExpiry.setMonth(newExpiry.getMonth() + months);

        sheet.getRange(i + 1, 3).setValue(newExpiry); // expiry
        sheet.getRange(i + 1, 4).setValue("live+"); // plan
        sheet.getRange(i + 1, 5).setValue(months); // plan_months

        return;
    }
}

function activateAndroidPurchase(email, purchaseToken, months) {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    let foundRow = -1;

    for (let i = 1; i < rows.length; i++) {

        const rowEmail = String(rows[i][0] || "").toLowerCase();
        const rowPlatform = String(rows[i][10] || "").toLowerCase();

        if (rowEmail === email.toLowerCase() && rowPlatform === "android") {
            foundRow = i;
            break;
        }
    }

    let baseDate = now;

    if (foundRow !== -1) {

        const currentExpiry = rows[foundRow][2] ? new Date(rows[foundRow][2]) : new Date(0);
        const currentPlan = String(rows[foundRow][3] || "").toLowerCase();

        if (currentPlan === "live+" && currentExpiry > now) {
            baseDate = currentExpiry;
        }

        const newExpiry = new Date(baseDate);
        newExpiry.setMonth(newExpiry.getMonth() + months);

        sheet.getRange(foundRow + 1, 3).setValue(newExpiry);
        sheet.getRange(foundRow + 1, 4).setValue("live+");
        sheet.getRange(foundRow + 1, 5).setValue(months);
        sheet.getRange(foundRow + 1, 12).setValue(purchaseToken);

        return {
            success: true,
            expiry: newExpiry
        };
    }

    // üöÄ If no android row exists ‚Üí create one
    const newExpiry = new Date(now);
    newExpiry.setMonth(newExpiry.getMonth() + months);

    sheet.appendRow([
        email,
        now,
        newExpiry,
        "live+",
        months,
        "",
        "",
        "",
        "",
        true,
        "android",
        purchaseToken
    ]);

    return {
        success: true,
        expiry: newExpiry
    };
}

function onBroadcast(text) {
    const msg = text.replace("/sendall", "").trim();
    if (!msg) return;

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {
        const chatId = String(rows[i][6] || "");
        if (!chatId) continue;
        send(chatId, "üì¢ <b>Announcement</b>\n\n" + msg);
    }

    send(ADMIN_CHAT_ID, "‚úÖ Broadcast sent");
}

function onAdminReply(text) {
    const parts = text.split(" ");
    if (parts.length < 3) return;

    const chatId = parts[1];
    const msg = parts.slice(2).join(" ");

    send(chatId, "üí¨ <b>Support</b>\n\n" + msg);
    send(ADMIN_CHAT_ID, "‚úÖ Reply sent to " + chatId);
}

function updateMarketNotes(text) {

    // EXPECTED FORMAT:
    // XAUUSD|Your 120 word commentary here...

    const idx = text.indexOf("|")
    if (idx === -1) return

    const pair = text.substring(0, idx).toUpperCase()
    const note = text.substring(idx + 1)

    if (PAIRS.indexOf(pair) === -1) return

    const notes = getMarketNotes()
    notes[pair] = note

    setMarketNotes(notes)
}

// ======================================================
// CALLBACK HANDLER
// ======================================================
function handleCallback(cq) {
    const chatId = String(cq.message.chat.id);
    answerCallback(cq.id);
    const cache = CacheService.getScriptCache();

    if (cq.data === "paid_confirm") {
        if (cache.get("paid_" + chatId)) return;
        cache.put("paid_" + chatId, "1", 3600);

        send(ADMIN_CHAT_ID, "üí≥ Payment confirmation\nChat ID: <code>" + chatId + "</code>");
        sendRich(chatId,
            "‚úÖ <b>Payment confirmation query received</b>\n\nYour subscription will be activated shortly.",
            null
        );
        return;
    }

    if (cq.data.startsWith("support_")) {
        send(ADMIN_CHAT_ID,
            "üÜò Support request\nType: " + cq.data + "\nChat ID: " + chatId
        );
        sendRich(chatId,
            "‚úÖ <b>Support request sent</b>\n\nOur team will review and respond if needed.",
            null
        );
    }

    if (cq.data.startsWith("inst_tmp_")) {

        const inst = cq.data.replace("inst_tmp_", "");
        let list = getTempInstruments(chatId) || [];

        if (list.indexOf(inst) !== -1) {
            list = list.filter(x => x !== inst);
        } else {
            list.push(inst);
        }

        setTempInstruments(chatId, list);

        editInstrumentPanel(chatId, cq.message.message_id, list);
        return;
    }

    if (cq.data === "inst_confirm") {

        const list = getTempInstruments(chatId) || [];
        saveInstrumentsToSheet(chatId, list);
        clearTempInstruments(chatId);

        editFinalInstrumentMessage(
            chatId,
            cq.message.message_id,
            list
        );
        return;
    }

    if (cq.data === "inst_cancel") {
        clearTempInstruments(chatId);

        const payload = {
            chat_id: chatId,
            message_id: cq.message.message_id,
            text: "‚ùå <b>Selection cancelled</b>",
            parse_mode: "HTML"
        };

        UrlFetchApp.fetch(
            "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
                method: "post",
                contentType: "application/json",
                payload: JSON.stringify(payload)
            }
        );
        return;
    }

}

function getUserInstruments(chatId) {

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][6]) === chatId) {

            const v = rows[i][5]; // Column F instruments
            return v ? String(v).split(",") : [];
        }
    }

    return [];
}

function editInstrumentPanel(chatId, messageId, selected) {

    const payload = {
        chat_id: chatId,
        message_id: messageId,
        text: "üìå <b>Select Trading Instruments</b>\n\nToggle pairs then press Confirm.",
        parse_mode: "HTML",
        reply_markup: buildInstrumentKeyboard(selected)
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload)
        }
    );
}

function getTempInstruments(chatId) {
    const cache = CacheService.getScriptCache();
    const raw = cache.get("inst_tmp_" + chatId);
    if (!raw) return null;
    return raw.split(",");
}

function setTempInstruments(chatId, list) {
    const cache = CacheService.getScriptCache();
    cache.put("inst_tmp_" + chatId, list.join(","), 600); // 10 minutes
}

function clearTempInstruments(chatId) {
    const cache = CacheService.getScriptCache();
    cache.remove("inst_tmp_" + chatId);
}

function saveInstrumentsToSheet(chatId, list) {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][6]) === chatId) {

            sheet.getRange(i + 1, 6).setValue(list.join(",")); // Column F
            return;
        }
    }
}

function editFinalInstrumentMessage(chatId, messageId, list) {

    const payload = {
        chat_id: chatId,
        message_id: messageId,
        text: "‚úÖ <b>Saved</b>\n\nYou will receive alerts only for:\n<b>" +
            (list.length ? list.join(", ") : "None") +
            "</b>",
        parse_mode: "HTML"
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload)
        }
    );
}

// ======================================================
// START / MENU / CORE UI (UNCHANGED)
// ======================================================
function onStart(chatId) {

    const row = getUserRow(chatId);

    if (!row) {

        sendRich(
            chatId,
            "üëã <b>Welcome to FXHEDZ LIVE</b>\n\n" +
            "To activate access:\n\n" +
            "1Ô∏è‚É£ Login inside the FXHEDZ app\n" +
            "2Ô∏è‚É£ Start your 14-day trial\n" +
            "3Ô∏è‚É£ Link this Telegram Chat ID\n\n" +
            "üÜî Your Chat ID:\n<code>" + chatId + "</code>\n\n" +
            "Open the app to continue.",
            null
        );

        return;
    }

    const now = new Date();

    const active =
        row.plan === "live+" ||
        (row.plan === "live" && row.expiry >= now);

    if (!active) {
        sendExpired(chatId);
        return;
    }

    sendMenu(
        chatId,
        "üëã <b>Welcome back</b>\n\n" +
        "Plan: " + row.plan.toUpperCase() + "\n" +
        "Valid till: " + formatDate(row.expiry)
    );
}

function sendMenu(chatId, text) {
    sendRich(chatId, text, getMainKeyboard());
}

function onPlan(chatId) {
    if (!isUserAllowed(chatId)) {
        sendExpired(chatId);
        return;
    }

    const row = getUserRow(chatId);

    sendMenu(
        chatId,
        "üìä <b>Subscription Plan</b>\n\n" +
        "Plan: " + row.plan.toUpperCase() + "\n" +
        "Valid till: " + formatDate(row.expiry)
    );
}

function onMyId(chatId) {
    sendRich(
        chatId,
        "üÜî <b>Your Telegram Chat ID</b>\n\n" +
        "<code>" + chatId + "</code>\n\n" +
        "This ID is used internally for subscription management.",
        null
    );
}

function onSubscription(chatId) {
    const row = getUserRow(chatId);
    const now = new Date();

    let planText;

    if (!row) {
        planText = "Plan: NOT FOUND";
    } else if (row.plan === "live+") {
        planText =
            "Plan: LIVE+\n" +
            "Valid till: " + formatDate(row.expiry);
    } else if (row.plan === "live" && row.expiry >= now) {
        planText =
            "Plan: LIVE\n" +
            "Valid till: " + formatDate(row.expiry);
    } else {
  const months = row.plan_months || 0;

  if (months > 0) {
    planText =
      "Plan: LIVE+\n" +
      "Status: Access Ended\n" +
      "Expired on: " + formatDate(row.expiry);
  } else {
    planText =
      "Plan: TRIAL\n" +
      "Status: TRIAL CONCLUDED\n" +
      "Expired on: " + formatDate(row.expiry);
  }
}

    sendRich(
        chatId,
        "üí≥ <b>FXHEDZ LIVE</b>\n\n" +
        planText + "\n\n" +
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
        "Upgrade to LIVE+ üëá\n\n" +
        "üî• <b>6 Months</b> is most popular\n" +
        "üíé <b>12 Months</b> is best value\n\n" +
        "üÜî <b>Chat ID</b>: " +
        "<code>" + chatId + "</code>\n\n" +
        "‚ö†Ô∏è <b>IMPORTANT</b>\n" +
        "Add your Chat ID in Razorpay payment notes", {
            inline_keyboard: [
                [{
                        text: "1 Month ¬∑ ‚Çπ999",
                        url: "https://rzp.io/rzp/QfdiMtK"
                    },
                    {
                        text: "3 Months ¬∑ ‚Çπ2,699",
                        url: "https://rzp.io/rzp/4cTq3B7l"
                    }
                ],
                [{
                        text: "6 Months ¬∑ ‚Çπ4,799",
                        url: "https://rzp.io/rzp/SRZIBEQP"
                    },
                    {
                        text: "12 Months ¬∑ ‚Çπ8,399",
                        url: "https://rzp.io/rzp/jPUuZy0"
                    }
                ],
                [{
                    text: "‚úÖ I Have Paid",
                    callback_data: "paid_confirm"
                }]
            ]
        }
    );
}

function onSupport(chatId) {
    sendRich(
        chatId,
        "üÜò <b>Support</b>\n\n" +
        "If you need assistance, please choose one option below.\n\n" +
        "‚ö†Ô∏è For faster resolution, avoid sending messages directly.", {
            inline_keyboard: [
                [{
                    text: "üí≥ Payment Issue",
                    callback_data: "support_payment"
                }],
                [{
                    text: "‚õî Access / Subscription Issue",
                    callback_data: "support_access"
                }],
                [{
                    text: "‚ùì General Query",
                    callback_data: "support_general"
                }]
            ]
        }
    );
}

function onBooks(chatId) {

    sendRich(
        chatId,
        "üìö <b>FXHEDZ Forex Trilogy (3 book series)</b>\n\n" +
        "Explore the official trilogy on Amazon:\n\n" +
        "üìò The Foundation of Forex Trading\n" +
        "üìô The Psychology of Forex Trading\n" +
        "üìó The Strategy of Forex Trading\n\n" +
        "Tap below to view:", {
            inline_keyboard: [
                [{
                    text: "üìö View on Amazon",
                    url: "https://www.amazon.com/dp/B0FQ11LS2Q?tag=global"
                }]
            ]
        }
    );
}

function isUserAllowed(chatId) {
    const row = getUserRow(chatId);
    if (!row) return false;

    const now = new Date();

    return row.plan === "live+" ||
        (row.plan === "live" && row.expiry >= now);
}

function sendExpired(chatId) {
    sendMenu(
        chatId,
        "‚õî <b>Subscription Expired</b>\n\n" +
        "‚ö†Ô∏è Your access to FXHEDZ LIVE has ended.\n\n" +
        "üìÖ Please renew your subscription to continue receiving:\n" +
        "üì¢ BUY | SELL | EXIT / HEDGE Alerts"
    );
}

function stripMachineHeader(text) {

    const lines = text.split("\n");

    if (!lines.length) return text;

    const parts = lines[0].split("|");

    // üî• remove ANY machine header >=5 segments
    if (parts.length >= 5) {
        lines.shift();
    }

    return lines.join("\n").trim();
}

// ======================================================
// SIGNAL BROADCAST
// ======================================================
function handleSignal(msg, tx) {
    msg = msg.trim()
        .replace(/^\/alert\b/i, "")
        .replace(/^\/ALERT\b/i, "")
        .trim();
    const cache = CacheService.getScriptCache();
    const signals = getLiveSignals();
    if (msg.startsWith("/history")) {
        handleHistory(msg.replace("/history", "").trim());
        return;
    }
    const firstLine = msg.split("\n")[0];
    // =========================
    // üî• MT5 LIVE CANDLE STREAM (50 candles)
    // =========================
    if (firstLine.startsWith("/tick")) {

        const clean = firstLine.replace("/tick", "").trim();
        const p = clean.split("|");

        const instrument = (p[0] || "").toUpperCase().trim();
        const price = p[1] || "0";

        if (PAIRS.indexOf(instrument) === -1) return;

        let positionsRaw = "";
        let candlesRaw = "";

        if (p.length === 4) {
            positionsRaw = p[2] || "";
            candlesRaw = p[3] || "";
        } else if (p.length === 3) {
            // no positions, only candles
            candlesRaw = p[2] || "";
        }

        // --------------------------
        // Parse positions
        // --------------------------
        let liveOrders = [];

        if (positionsRaw) {

            const list = positionsRaw.split(";").filter(Boolean);

            list.forEach(row => {

                const o = row.split(",");
                if (o.length < 3) return;

                const rowSymbol = (o[0] || "").toUpperCase().trim();
                if (rowSymbol !== instrument) return;

                liveOrders.push({
                    id: Utilities.getUuid(),
                    label: "",
                    direction: "",
                    entry: 0,
                    lots: Number(o[1] || 0),
                    profit: Number(o[2] || 0),
                    time: Utilities.formatDate(new Date(), "GMT", "HH:mm:ss")
                });
            });
        }

        // --------------------------
        // Parse candles
        // --------------------------
        let candles = [];

        if (candlesRaw) {

            const list = candlesRaw.split(";");

            list.forEach(row => {

                const c = row.split(",");
                if (c.length < 5) return;

                candles.push({
                    time: Number(c[0]),
                    open: Number(c[1]),
                    high: Number(c[2]),
                    low: Number(c[3]),
                    close: Number(c[4])
                });
            });
        }

        const prevOrders = signals[instrument]?.orders || [];

        const updatedOrders = prevOrders.map((order, index) => {
            const live = liveOrders[index];
            return {
                ...order,
                profit: live ? live.profit : order.profit
            };
        });

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                price: price,
                candles: candles,
                orders: updatedOrders
            }
        };

        setLiveSignals(updated);
        return;

    }

    if (firstLine.indexOf("|") !== -1) {

        const parts = firstLine.split("|");
        const ordersField = parts[10] || "";
        const posLots = Number(parts[8] || 0);

        const sideField = parts[9] || "";
        const orderSide = sideField.replace("SIDE=", "");

        const instrument = (parts[0] || "").toUpperCase().trim();
        if (PAIRS.indexOf(instrument) === -1) return;

        const direction = parts[1].replace(/<[^>]*>/g, "");
        const entry = parts[2];
        const sl = parts[3];
        const tp = parts[4];
        const lots = parts[5];
        const buys = parts[6];
        const sells = parts[7];
        // keep previous orders
        const prevOrders = (signals[instrument]?.orders || []).slice()
        let profit = 0;

        let parsedOrders = [];

        if (ordersField.startsWith("ORDERS=")) {

            const raw = ordersField.replace("ORDERS=", "");
            const list = raw.split(";").filter(Boolean);

            parsedOrders = list.map(row => {

                const o = row.split(",");

                return {
                    label: o[0],
                    entry: o[1],
                    lots: Number(o[2] || 0),
                    profit: Number(o[3] || 0)
                };
            });
        }

        let newOrders = prevOrders

        if (direction === "EXIT") {

            // EXIT clears all
            newOrders = []

        } else {

            const rawDir = parts[1].toUpperCase()

            let orderDirection = rawDir
            let hedged = false

            if (rawDir === "HEDGED") {

                hedged = true

                // üî• get LAST REAL ORDER SIDE
                const lastOrder =
                    prevOrders.length ?
                    prevOrders[prevOrders.length - 1] :
                    null

                if (lastOrder && lastOrder.direction) {

                    // hedge = opposite of last order
                    orderDirection =
                        lastOrder.direction === "BUY" ?
                        "SELL" :
                        "BUY"

                } else {

                    // fallback safety
                    orderDirection = "BUY"
                }
            }

            newOrders = parsedOrders.map(o => ({
                id: Utilities.getUuid(),
                label: o.label,
                direction: o.label.startsWith("B") ? "BUY" : "SELL",
                hedged: direction === "HEDGED",
                entry: o.entry,
                lots: o.lots,
                profit: o.profit,
                time: Utilities.formatDate(new Date(), "GMT", "HH:mm:ss")
            }));

        }

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                direction: direction,
                entry: direction === "EXIT" ? null : entry,
                sl: direction === "EXIT" ? null : sl,
                tp: direction === "EXIT" ? null : tp,
                price: entry,
                lots: Number(lots || 0),
                buys: Number(buys || 0),
                sells: Number(sells || 0),
                orders: newOrders
            }
        };

        setLiveSignals(updated);

        if (tx && instrument) {

            // small delay ensures cache visible to parallel execution
            Utilities.sleep(150);

            cache.put(
                "tx_" + tx,
                JSON.stringify({
                    instrument: instrument,
                    text: stripMachineHeader(msg)
                }),
                120 // longer TTL
            );
        }
        return;
    }

    const text = msg.toUpperCase();
    const parts = text.split(/\s+/);

    const instrument = parts[0] || null;
    const direction = (parts[1] || "").replace(/<[^>]*>/g, "");

    // =========================
    // üî• PRICE UPDATE ENGINE
    // =========================
    // Handles messages like:
    // BTCUSD 49721.3
    if (parts.length === 2 && !(direction || "").match(/BUY|SELL|EXIT/)) {

        const price = parts[1];

        if (signals[instrument]) {

            const updated = {
                ...signals,
                [instrument]: {
                    ...(signals[instrument] || {}),
                    price: price
                }
            };

            setLiveSignals(updated);
        }

        return; // üö® IMPORTANT ‚Äî stop here
    }

    // =========================
    // üî• ALERT PARSER
    // =========================

    const slMatch = text.match(/SL(?:\/HEDZ)?[:\s]+([\d\.]+)/);
    const tpMatch = text.match(/TP(?:\d)?[:\s]+([\d\.]+)/);
    const entryMatch =
        text.match(/PRICE[:\s]+([\d\.]+)/) ||
        text.match(/PRICE<\/B>[:\s]*([\d\.]+)/i) ||
        text.match(/<B>PRICE:<\/B>\s*([\d\.]+)/i);

    const sl = slMatch ? slMatch[1] : null;
    const tp = tpMatch ? tpMatch[1] : null;
    const entry = entryMatch ? entryMatch[1] : null;

    if (instrument && direction) {

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                direction: direction,
                entry: entry || signals[instrument]?.entry,
                sl: direction === "HEDGED" ? null : sl,
                tp: direction === "HEDGED" ? null : tp,
                price: entry || signals[instrument]?.price,
                trend: "H1 Trend Strong"
            }
        };

        setLiveSignals(updated);

    }

    if (tx) {
        cache.put(
            "tx_" + tx,
            JSON.stringify({
                instrument: instrument,
                text: stripMachineHeader(msg)
            }),
            60
        );
    }
}

function handleHistory(text) {

    const parts = text.split(/\s+/)

    // EXPECTED:
    // XAUUSD SELL 4996.4 4956.7 -124.3 2026-02-13T10:22

    const instrument = (parts[0] || "").toUpperCase()
    const direction = (parts[1] || "").toUpperCase()

    if (PAIRS.indexOf(instrument) === -1) return
    if (["BUY", "SELL"].indexOf(direction) === -1) return

    const entry = parts[2]
    const exit = parts[3]
    const pnl = parts[4]
    const time = parts[5] || Utilities.formatDate(new Date(), "GMT", "yyyy-MM-dd'T'HH:mm")

    if (!instrument || !entry || !exit) return

    const cache = CacheService.getScriptCache()
    const hash = instrument + "|" + entry + "|" + exit + "|" + time

    // üî• duplicate protection
    if (cache.get(hash)) return
    cache.put(hash, "1", 30)

    // ‚úÖ WRITE TO GOOGLE SHEET (MASTER HISTORY)
    appendHistoryRow(instrument, direction, entry, exit, pnl, time)

    // OPTIONAL: keep small live cache for miniapp speed
    const history = getOrderHistory()

    if (!history[instrument]) history[instrument] = []

    history[instrument].unshift({
        direction,
        entry,
        exit,
        pnl: Number(pnl),
        time
    })

    history[instrument] = history[instrument].slice(0, 50)

    setOrderHistory(history)

    // ==============================
    // üî• LIVE PERFORMANCE UPDATE
    // ==============================

    const perfCache = getPairPerformanceCache()

    if (!perfCache[instrument]) {
        perfCache[instrument] = {
            trades: 0,
            wins: 0,
            losses: 0,
            pnlTotal: 0,
            profit: 0,
            loss: 0
        }
    }

    const p = perfCache[instrument]
    const pnlNum = Number(pnl) || 0

    p.trades++
    p.pnlTotal += pnlNum

    if (pnlNum >= 0) {
        p.wins++
        p.profit += pnlNum
    } else {
        p.losses++
        p.loss += Math.abs(pnlNum)
    }

    p.winRate = p.trades ? (p.wins / p.trades) * 100 : 0
    p.profitFactor = p.loss ? (p.profit / p.loss) : p.profit

    setPairPerformanceCache(perfCache)

}

function getPairDataFromSheet(pair) {

    const sheet = SpreadsheetApp
        .openById(SPREADSHEET_ID)
        .getSheetByName("ORDER_HISTORY")

    const lastRow = sheet.getLastRow()
    if (lastRow < 2) {
        return {
            history: [],
            performance: {}
        }
    }

    const rows = sheet.getRange(1, 1, lastRow, 6).getValues()

    const history = []

    let wins = 0,
        losses = 0,
        pnlTotal = 0,
        profit = 0,
        loss = 0,
        trades = 0

    for (let i = rows.length - 1; i >= 1; i--) {

        if (rows[i][1] !== pair) continue

        const pnl = Number(rows[i][5]) || 0

        // ===== history (latest 100)
        if (history.length < 100) {
            history.push({
                time: rows[i][0],
                direction: rows[i][2],
                entry: rows[i][3],
                exit: rows[i][4],
                pnl: pnl
            })
        }

        // ===== performance
        pnlTotal += pnl
        trades++

        if (pnl >= 0) {
            wins++
            profit += pnl
        } else {
            losses++
            loss += Math.abs(pnl)
        }
    }

    const winRate = trades ? (wins / trades) * 100 : 0
    const profitFactor = loss ? (profit / loss) : profit

    return {
        history,
        performance: {
            trades,
            wins,
            losses,
            winRate: Number(winRate.toFixed(1)),
            pnlTotal: Number(pnlTotal.toFixed(2)),
            profitFactor: Number(profitFactor.toFixed(2))
        }
    }
}

// ======================================================
// IMAGE BROADCAST
// ======================================================
function dispatchImageToUsers(blob, tx) {
    const cache = CacheService.getScriptCache();

    let payload = null;

    if (tx) {

        // retry up to 5 times because image can arrive first
        for (let i = 0; i < 5; i++) {

            const raw = cache.get("tx_" + tx);

            if (raw) {
                payload = JSON.parse(raw);
                break;
            }

            Utilities.sleep(250); // wait 250ms
        }
    }

    const instrument = payload ? payload.instrument : null;
    // ‚úÖ ALSO UPDATE MINIAPP STATE FROM IMAGE FLOW
    if (payload && payload.text) {
        handleSignal(payload.text, null);
        const parts = payload.text.trim().split(/\s+/);
        const direction = parts.length > 1 ?
            parts[1].toUpperCase().replace(/<[^>]*>/g, "") :
            null;

        if (instrument && direction) {

            const signals = getLiveSignals();

            const updated = {
                ...signals,
                [instrument]: {
                    ...(signals[instrument] || {}),
                    direction: direction,
                    trend: "H1 Trend Strong"
                }
            };

            setLiveSignals(updated);

        }

    }

    const caption = payload ?
        stripMachineHeader(payload.text) :
        "üìä FXHEDZ Chart Snapshot";

    const rows = mustGetSheet().getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        const chatId = String(rows[i][6] || "");
        if (!chatId) continue;

        const expiry = rows[i][2] ? new Date(rows[i][2]) : new Date(0);
        const plan = String(rows[i][3] || "").toLowerCase();
        const instruments = rows[i][5] ?
            String(rows[i][5]).split(",") : [];

        if (plan !== "live+" && !(plan === "live" && expiry > now)) {
            continue;
        }

        if (instrument && instruments.length &&
            instruments.indexOf(instrument) === -1) {
            continue;
        }

        UrlFetchApp.fetch(
            "https://api.telegram.org/bot" + TOKEN + "/sendPhoto", {
                method: "post",
                payload: {
                    chat_id: chatId,
                    photo: blob,
                    caption: caption,
                    parse_mode: "HTML"
                },
                muteHttpExceptions: true
            }
        );
    }

    if (tx) cache.remove("tx_" + tx);
}

function setMenuButton() {

    const url = "https://api.telegram.org/bot" + TOKEN + "/setChatMenuButton";

    const payload = {
        menu_button: {
            type: "web_app",
            text: "üö¶ Signals",
            web_app: {
                url: "https://fxhedz.vercel.app/"
            }
        }
    };

    UrlFetchApp.fetch(url, {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify(payload)
    });
}

// ======================================================
// UTILITIES (UNCHANGED)
// ======================================================
function getMainKeyboard() {
    return {
        keyboard: [
            [{
                    text: "üí± PAIR"
                },
                {
                    text: "üëë LIVE+"
                },
                {
                    text: "üìö READ"
                },
                {
                    text: "üÜò HELP"
                }
            ]
        ],
        resize_keyboard: true,
        is_persistent: true,
        one_time_keyboard: false
    };
}

function debugSignals() {
    const raw = PropertiesService.getScriptProperties().getProperty("LIVE_SIGNALS");
    Logger.log(raw);
}

function getUserRow(chatId) {

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][6]) === chatId) {

            return {
                rowIndex: i + 1,
                email: rows[i][0],
                expiry: rows[i][2] ? new Date(rows[i][2]) : new Date(0),
                plan: String(rows[i][3] || "").toLowerCase(),
                plan_months: rows[i][4] || 0,
                instruments: rows[i][5] ? String(rows[i][5]).split(",") : []
            };
        }
    }

    return null;
}

function send(chatId, text) {
    sendRich(chatId, text, null);
}

function sendRich(chatId, text, markup) {
    const payload = {
        chat_id: chatId,
        text,
        parse_mode: "HTML",
        reply_markup: markup ? markup : getMainKeyboard()
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/sendMessage", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload),
            muteHttpExceptions: true
        }
    );
}

function answerCallback(id) {
    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/answerCallbackQuery", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify({
                callback_query_id: id
            })
        }
    );
}

function formatDate(d) {
    return Utilities.formatDate(new Date(d), "GMT+5:30", "dd MMM yyyy");
}

function ok() {
    return HtmlService.createHtmlOutput("OK");
}

// RUN ONCE DAILY
function nightlyExpirySweep() {
    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        const expiry = rows[i][2] ? new Date(rows[i][2]) : new Date(0);
        const plan = String(rows[i][3] || "").toLowerCase();

        if (plan === "live+" && expiry < now) {
            sheet.getRange(i + 1, 4).setValue("expired");
        }
    }
}

// RUN ONLY WHEN DEPLOYMENT URL CHANGES
function resetAndSetWebhook() {
    const TOKEN = PropertiesService.getScriptProperties().getProperty("BOT_TOKEN");
    const WEBHOOK_URL = "https://script.google.com/macros/s/AKfycby55ye_dTtWJ-QILNYJIaXWv74_n7n0muh3U--sBl7yowMlp1FzESOokWqeHI75U5_R/exec";
    const base = "https://api.telegram.org/bot" + TOKEN;

    UrlFetchApp.fetch(base + "/deleteWebhook", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            drop_pending_updates: true
        })
    });

    Utilities.sleep(3000);

    UrlFetchApp.fetch(base + "/setWebhook", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            url: WEBHOOK_URL
        })
    });
}